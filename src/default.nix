let
  utils = import ./lib.nix;
  perform = import ./collect.nix;
  inherit (utils) inModuleEval;

  # Standalone utilities (no nixpkgs dependency)
  collectInputs = import ./collect-inputs.nix;
  flakeFormat = import ./format-flake.nix;
  inherit (flakeFormat) formatInputs formatFlake;

  # Registry utilities (requires lib)
  registryModule = import ./registry.nix;

  # Convenience: collect inputs and format as flake.nix
  collectAndFormatFlake =
    {
      src,
      coreInputs ? { },
      description ? "",
      outputsFile ? "./outputs.nix",
      header ? "# Auto-generated by imp - DO NOT EDIT\n# Regenerate with: nix run .#imp-flake",
    }:
    let
      collectedInputs = collectInputs src;
    in
    formatFlake {
      inherit
        description
        coreInputs
        collectedInputs
        outputsFile
        header
        ;
    };

  # Makes imp callable: imp ./path or imp { config, ... }
  functor = self: arg: perform self.__config (if inModuleEval arg then [ ] else arg);

  # The imp builder object - a stateful configuration that produces the API
  callable =
    let
      # Initial configuration state
      initial = {
        api = { };
        mapf = (i: i);
        treef = import;
        filterf = _: true;
        paths = [ ];

        # State functor: receives update function, returns new state with bound API
        __functor =
          config: update:
          let
            updated = update config;
            current = config update;
            boundAPI = builtins.mapAttrs (_: g: g current) updated.api;

            # Import API methods with current state
            apiMethods = import ./api.nix {
              inherit
                config
                update
                updated
                current
                callable
                ;
            };
          in
          boundAPI
          // apiMethods
          // {
            __config = updated;
            __functor = functor;

            # Standalone utilities available on imp object
            inherit
              collectInputs
              formatInputs
              formatFlake
              collectAndFormatFlake
              registryModule
              ;

            # Convenience: build registry with current lib
            # Usage: (imp.withLib lib).registry ./nix
            registry =
              path:
              if updated.lib == null then
                throw "You need to call withLib before using registry."
              else
                (registryModule { lib = updated.lib; }).buildRegistry path;
          };
      };
    in
    initial (config: config);

in
callable

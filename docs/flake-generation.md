# imp Flake Generation - Technical Specification

## Overview

This document specifies the design for adding flake.nix generation capabilities to imp, allowing flake inputs to be declared inline alongside the code that uses them.

## Problem Statement

Nix flakes require the `inputs` attribute to be a **statically-defined attribute set**. This means:
- Inputs cannot be computed dynamically
- Inputs cannot use `import` or `//` operators
- All dependencies must be declared upfront in `flake.nix`

This creates a maintenance burden where inputs are declared far from where they're used, and adding a new dependency requires editing multiple files.

## Goals

1. **Co-located dependencies**: Declare inputs next to the code that uses them
2. **Auto-generated flake.nix**: Generate a valid flake.nix from collected inputs
3. **Minimal boilerplate**: Simpler than flake-file's module options approach
4. **Validation**: Ensure generated flake.nix stays in sync with declarations
5. **Seamless integration**: Work naturally with imp's existing tree/module system

## Design

### 1. Input Declaration Pattern

Files declare their input requirements using a `__inputs` attribute:

```nix
# nix/outputs/perSystem/formatter.nix
{
  __inputs.treefmt-nix = {
    url = "github:numtide/treefmt-nix";
  };

  __functor = _: { pkgs, inputs, ... }:
    inputs.treefmt-nix.lib.evalModule pkgs {
      projectRootFile = "flake.nix";
      programs.nixfmt.enable = true;
    };
}
```

For files that don't need special attributes, a simpler pattern using a wrapper:

```nix
# nix/outputs/nixosConfigurations/workstation.nix
{
  __inputs.home-manager = {
    url = "github:nix-community/home-manager";
    inputs.nixpkgs.follows = "nixpkgs";
  };

  __functor = _: { lib, inputs, ... }:
    lib.nixosSystem {
      system = "x86_64-linux";
      modules = [
        inputs.home-manager.nixosModules.home-manager
        # ...
      ];
    };
}
```

### 2. Input Schema

The `__inputs` attribute supports the full flake input schema:

```nix
__inputs.<name> = {
  # Source (one of these)
  url = "github:owner/repo";        # URL shorthand
  type = "github";                   # Explicit type
  owner = "owner";                   # For typed refs
  repo = "repo";
  path = "/path/to/flake";          # Local path
  
  # Pinning
  ref = "main";                      # Branch/tag
  rev = "abc123...";                 # Commit hash
  narHash = "sha256-...";           # Content hash
  
  # Options
  flake = true;                      # Is it a flake? (default: true)
  dir = "subdir";                    # Subdirectory
  submodules = false;                # Fetch git submodules
  
  # Follows
  follows = "nixpkgs";               # Follow another input
  inputs.<dep>.follows = "nixpkgs";  # Nested follows
};
```

### 3. Core Inputs vs Collected Inputs

The flake.nix will have two sections:

```nix
{
  inputs = {
    # === Core (always required) ===
    nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
    flake-parts.url = "github:hercules-ci/flake-parts";
    imp.url = "github:user/imp";
    
    # === Auto-generated from __inputs ===
    home-manager = { ... };
    treefmt-nix = { ... };
  };
}
```

Core inputs are defined in a `nix/inputs/core.nix` file:

```nix
# nix/inputs/core.nix
{
  nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
  flake-parts.url = "github:hercules-ci/flake-parts";
  imp.url = "github:user/imp";
}
```

### 4. Collection Algorithm

```
collectInputs : Path -> AttrSet

1. If path is a .nix file:
   - Import the file
   - If result has __inputs, return it
   - Otherwise return {}

2. If path is a directory:
   - For each entry (excluding _-prefixed):
     - If .nix file: extract __inputs
     - If directory with default.nix: extract __inputs from default.nix
     - If directory without default.nix: recurse
   - Merge all collected inputs
   - On conflict (same name, different definition): throw error
   
3. Return merged inputs attrset
```

### 5. Conflict Detection

When the same input is declared in multiple files:

```nix
# file-a.nix
{ __inputs.foo.url = "github:a/foo"; }

# file-b.nix  
{ __inputs.foo.url = "github:b/foo"; }  # CONFLICT!
```

The collector will throw:
```
error: imp.collectInputs: conflicting definitions for input 'foo'
  - nix/outputs/file-a.nix: github:a/foo
  - nix/outputs/file-b.nix: github:b/foo
```

Identical declarations are allowed and merged silently.

### 6. Flake Generation

#### Template Structure

```nix
# Auto-generated by imp - DO NOT EDIT
# Regenerate with: nix run .#gen-flake
{
  description = "<description>";
  
  inputs = <merged core + collected inputs>;
  
  outputs = inputs: import ./outputs.nix inputs;
}
```

#### outputs.nix Pattern

```nix
# outputs.nix - The actual flake logic
inputs:
let
  inherit (inputs) nixpkgs flake-parts imp;
  lib = nixpkgs.lib;
in
flake-parts.lib.mkFlake { inherit inputs; } {
  imports = [ imp.flakeModules.default ];
  
  systems = [ "x86_64-linux" "aarch64-linux" ];
  
  imp = {
    src = ./nix/outputs;
    args = { inherit inputs lib; };
  };
}
```

### 7. API Additions to imp

#### New Functions

```nix
# Collect __inputs from a directory tree (standalone, no nixpkgs needed)
imp.collectInputs : Path -> AttrSet

# Format inputs as Nix source code
imp.formatInputs : AttrSet -> String

# Collect and format in one step
imp.collectAndFormatInputs : Path -> String
```

#### New flakeModule Options

```nix
{
  options.imp = {
    # Existing options...
    src = mkOption { ... };
    args = mkOption { ... };
    perSystemDir = mkOption { ... };
    
    # New options for flake generation
    flakeFile = {
      enable = mkEnableOption "flake.nix generation";
      
      description = mkOption {
        type = types.str;
        default = "";
        description = "Flake description";
      };
      
      coreInputs = mkOption {
        type = types.path;
        default = null;
        description = "Path to core inputs file";
      };
      
      outputsFile = mkOption {
        type = types.str;
        default = "./outputs.nix";
        description = "Path to outputs.nix (relative to flake.nix)";
      };
      
      doNotEditHeader = mkOption {
        type = types.str;
        default = "# Auto-generated by imp - DO NOT EDIT";
      };
    };
  };
}
```

#### New Outputs

```nix
perSystem = { pkgs, ... }: {
  # App to regenerate flake.nix
  packages.gen-flake = ...;
  apps.gen-flake = ...;
  
  # Check that flake.nix is up-to-date
  checks.flake-up-to-date = ...;
};
```

### 8. File Structure Convention

```
my-flake/
├── flake.nix           # Auto-generated
├── flake.lock
├── outputs.nix         # Flake outputs entry point
└── nix/
    ├── inputs/
    │   └── core.nix    # Core/required inputs
    └── outputs/
        ├── perSystem/
        │   ├── formatter.nix   # Has __inputs.treefmt-nix
        │   └── devShells.nix
        └── nixosConfigurations/
            └── server.nix      # Has __inputs.home-manager
```

### 9. Implementation Plan

#### Phase 1: Standalone Input Collection
1. Create `src/collect-inputs.nix` - standalone collector (no nixpkgs dependency)
2. Add `collectInputs` to API
3. Add tests for collection and conflict detection

#### Phase 2: Flake Generation
1. Create `src/format-flake.nix` - Nix source code generation
2. Create `src/flake-file.nix` - flakeModule additions
3. Add `gen-flake` app and check

#### Phase 3: Integration
1. Update flakeModule with new options
2. Add documentation
3. Create migration guide

### 10. Usage Example

#### Initial Setup

```bash
# Initialize with template
nix flake init -t github:user/imp#flake-file

# Or migrate existing flake
# 1. Move flake.nix logic to outputs.nix
# 2. Create nix/inputs/core.nix with essential inputs
# 3. Add __inputs to files that need them
# 4. Run gen-flake
nix run .#gen-flake
```

#### Day-to-Day Workflow

```bash
# After adding a new dependency via __inputs
nix run .#gen-flake

# Or in a git hook / devshell
# The check will fail if flake.nix is out of date
nix flake check
```

### 11. Comparison with flake-file

| Aspect | flake-file | imp (proposed) |
|--------|------------|----------------|
| Input declaration | Module options (`flake-file.inputs.X.url`) | Inline attribute (`__inputs.X.url`) |
| Location | Any flake-parts module | Same file that uses the input |
| Verbosity | More verbose | More concise |
| Schema validation | Full NixOS module types | Simple attrset |
| Flexibility | High (hooks, formatters) | Focused (just inputs) |
| Dependencies | import-tree, flake-parts | None (standalone collector) |

### 12. Open Questions

1. **Should functor pattern be required?** 
   - Pro: Consistent structure, easy to detect
   - Con: Extra boilerplate for simple files
   - Decision: Optional - detect `__inputs` on any attrset

2. **How to handle conditional inputs?**
   - Some inputs only needed on certain platforms
   - Could add `__inputs.<name>.platforms = [ "x86_64-linux" ]`
   - Decision: Defer to future enhancement

3. **Should we support flake-file compatibility?**
   - Could read `flake-file.inputs` option as alternative source
   - Decision: Out of scope for initial implementation

### 13. Success Criteria

1. Users can declare inputs inline with `__inputs`
2. `nix run .#gen-flake` generates valid flake.nix
3. `nix flake check` validates flake.nix is current
4. Zero runtime overhead (generation is a dev-time operation)
5. Works with existing imp features (tree, configTree, filters)
